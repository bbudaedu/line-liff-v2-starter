/**
 * @jest-environment jsdom
 */

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { useRouter } from 'next/router';
import EventsPage from '../../pages/events/index';
import EventDetailsPage from '../../pages/events/[id]';
import { useIdentity } from '../../hooks/useIdentity';
import { apiClient } from '../../services/api';

// Mock dependencies
jest.mock('next/router', () => ({
  useRouter: jest.fn(),
}));

jest.mock('../../hooks/useIdentity', () => ({
  useIdentity: jest.fn(),
  useIdentityLabels: jest.fn(),
}));

jest.mock('../../services/api', () => ({
  apiClient: {
    get: jest.fn(),
  },
  handleApiError: jest.fn(),
}));

const mockRouter = {
  push: jest.fn(),
  query: {},
};

const mockIdentity = {
  identity: 'monk' as const,
  hasSelectedIdentity: true,
  isLoading: false,
  clearIdentity: jest.fn(),
};

const mockEvents = [
  {
    id: 'event-1',
    name: '‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ',
    description: 'Âπ¥Â∫¶‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ',
    startDate: new Date('2024-12-25T09:00:00'),
    endDate: new Date('2024-12-25T17:00:00'),
    location: 'ÂΩ∞ÂåñÁ∏£ÊüêÂØ∫Èô¢',
    maxParticipants: 100,
    currentParticipants: 50,
    registrationDeadline: new Date('2024-12-20T23:59:59'),
    status: 'open' as const,
    pretixEventSlug: 'test-event',
    transportOptions: [
      {
        id: 'transport-1',
        eventId: 'event-1',
        name: 'ÂΩ∞ÂåñÁÅ´ËªäÁ´ô',
        address: 'ÂΩ∞ÂåñÁ∏£ÂΩ∞ÂåñÂ∏Ç‰∏âÊ∞ëË∑Ø1Ëôü',
        pickupTime: new Date('2024-12-25T07:30:00'),
        maxSeats: 45,
        bookedSeats: 20,
        coordinates: { lat: 24.0818, lng: 120.5387 },
      },
    ],
  },
  {
    id: 'event-2',
    name: 'Â∑≤È°çÊªøÊ¥ªÂãï',
    description: 'ÈÄôÊòØ‰∏ÄÂÄãÂ∑≤È°çÊªøÁöÑÊ¥ªÂãï',
    startDate: new Date('2024-12-30T09:00:00'),
    endDate: new Date('2024-12-30T17:00:00'),
    location: 'ÂΩ∞ÂåñÁ∏£ÊüêÂØ∫Èô¢',
    maxParticipants: 50,
    currentParticipants: 50,
    registrationDeadline: new Date('2024-12-25T23:59:59'),
    status: 'open' as const,
    pretixEventSlug: 'full-event',
    transportOptions: [],
  },
];

const mockEventDetails = {
  ...mockEvents[0],
  registrationStats: {
    total: 50,
    monks: 30,
    volunteers: 20,
  },
};

describe('Events Pages', () => {
  beforeEach(() => {
    (useRouter as jest.Mock).mockReturnValue(mockRouter);
    (useIdentity as jest.Mock).mockReturnValue(mockIdentity);
    (require('../../hooks/useIdentity').useIdentityLabels as jest.Mock).mockReturnValue({
      label: 'Ê≥ïÂ∏´',
      icon: 'üßò‚Äç‚ôÇÔ∏è',
    });
    jest.clearAllMocks();
  });

  describe('EventsPage', () => {
    it('should render loading state initially', () => {
      (apiClient.get as jest.Mock).mockImplementation(() => new Promise(() => {}));

      render(<EventsPage />);

      expect(screen.getByText('ËºâÂÖ•‰∏≠ - Ê¥ªÂãïÂàóË°®')).toBeInTheDocument();
    });

    it('should redirect to home if identity not selected', () => {
      (useIdentity as jest.Mock).mockReturnValue({
        ...mockIdentity,
        hasSelectedIdentity: false,
      });

      render(<EventsPage />);

      expect(mockRouter.push).toHaveBeenCalledWith('/');
    });

    it('should render events list successfully', async () => {
      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: mockEvents,
      });

      render(<EventsPage />);

      await waitFor(() => {
        expect(screen.getByText('Ê¥ªÂãïÂàóË°®')).toBeInTheDocument();
        expect(screen.getByText('‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ')).toBeInTheDocument();
        expect(screen.getByText('Â∑≤È°çÊªøÊ¥ªÂãï')).toBeInTheDocument();
      });
    });

    it('should handle API error', async () => {
      const mockError = new Error('API Error');
      (apiClient.get as jest.Mock).mockRejectedValue(mockError);
      (require('../../services/api').handleApiError as jest.Mock).mockReturnValue('ËºâÂÖ•Â§±Êïó');

      render(<EventsPage />);

      await waitFor(() => {
        expect(screen.getByText('ËºâÂÖ•Â§±Êïó')).toBeInTheDocument();
      });
    });

    it('should filter events by search term', async () => {
      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: mockEvents,
      });

      render(<EventsPage />);

      await waitFor(() => {
        expect(screen.getByText('‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ')).toBeInTheDocument();
      });

      const searchInput = screen.getByPlaceholderText('ÊêúÂ∞ãÊ¥ªÂãïÂêçÁ®±ÊàñÂú∞Èªû...');
      fireEvent.change(searchInput, { target: { value: '‰æõ‰Ωõ' } });

      expect(screen.getByText('‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ')).toBeInTheDocument();
      expect(screen.queryByText('Â∑≤È°çÊªøÊ¥ªÂãï')).not.toBeInTheDocument();
    });

    it('should filter events by status', async () => {
      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: mockEvents,
      });

      render(<EventsPage />);

      await waitFor(() => {
        expect(screen.getByText('‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ')).toBeInTheDocument();
      });

      const openFilter = screen.getByText('ÈñãÊîæÂ†±Âêç');
      fireEvent.click(openFilter);

      // ÊáâË©≤Âè™È°ØÁ§∫ÈñãÊîæÂ†±ÂêçÁöÑÊ¥ªÂãï
      expect(screen.getByText('‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ')).toBeInTheDocument();
    });

    it('should navigate to event details when clicking event card', async () => {
      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: mockEvents,
      });

      render(<EventsPage />);

      await waitFor(() => {
        expect(screen.getByText('‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ')).toBeInTheDocument();
      });

      const eventCard = screen.getByText('‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ').closest('.event-card');
      if (eventCard) {
        fireEvent.click(eventCard);
        expect(mockRouter.push).toHaveBeenCalledWith('/events/event-1');
      }
    });

    it('should show empty state when no events match filters', async () => {
      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: [],
      });

      render(<EventsPage />);

      await waitFor(() => {
        expect(screen.getByText('ÁõÆÂâçÊ≤íÊúâÁ¨¶ÂêàÊ¢ù‰ª∂ÁöÑÊ¥ªÂãï')).toBeInTheDocument();
      });
    });

    it('should navigate back to home', async () => {
      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: mockEvents,
      });

      render(<EventsPage />);

      await waitFor(() => {
        expect(screen.getByText('Ê¥ªÂãïÂàóË°®')).toBeInTheDocument();
      });

      const backButton = screen.getByText('‚Üê ËøîÂõûÈ¶ñÈ†Å');
      fireEvent.click(backButton);

      expect(mockRouter.push).toHaveBeenCalledWith('/');
    });
  });

  describe('EventDetailsPage', () => {
    beforeEach(() => {
      mockRouter.query = { id: 'event-1' };
    });

    it('should render loading state initially', () => {
      (apiClient.get as jest.Mock).mockImplementation(() => new Promise(() => {}));

      render(<EventDetailsPage />);

      // Check for skeleton loading elements instead of title text
      expect(document.querySelector('.skeleton')).toBeInTheDocument();
    });

    it('should redirect to home if identity not selected', () => {
      (useIdentity as jest.Mock).mockReturnValue({
        ...mockIdentity,
        hasSelectedIdentity: false,
      });

      render(<EventDetailsPage />);

      expect(mockRouter.push).toHaveBeenCalledWith('/');
    });

    it('should render event details successfully', async () => {
      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: mockEventDetails,
      });

      render(<EventDetailsPage />);

      await waitFor(() => {
        expect(screen.getByText('‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ')).toBeInTheDocument();
        expect(screen.getByText('Âπ¥Â∫¶‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ')).toBeInTheDocument();
        expect(screen.getByText('ÂΩ∞ÂåñÁ∏£ÊüêÂØ∫Èô¢')).toBeInTheDocument();
        expect(screen.getByText('50')).toBeInTheDocument(); // current participants
        expect(screen.getByText('100')).toBeInTheDocument(); // max participants
      });
    });

    it('should show transport options', async () => {
      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: mockEventDetails,
      });

      render(<EventDetailsPage />);

      await waitFor(() => {
        expect(screen.getByText('‰∫§ÈÄöËªäË≥áË®ä')).toBeInTheDocument();
        expect(screen.getByText('ÂΩ∞ÂåñÁÅ´ËªäÁ´ô')).toBeInTheDocument();
        expect(screen.getByText((content, element) => {
          return element?.textContent === 'üìçÂΩ∞ÂåñÁ∏£ÂΩ∞ÂåñÂ∏Ç‰∏âÊ∞ëË∑Ø1Ëôü';
        })).toBeInTheDocument();
      });
    });

    it('should show registration statistics', async () => {
      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: mockEventDetails,
      });

      render(<EventDetailsPage />);

      await waitFor(() => {
        expect(screen.getByText('Â†±ÂêçÁµ±Ë®à')).toBeInTheDocument();
        expect(screen.getByText('Ê≥ïÂ∏´Ôºö30 ‰∫∫')).toBeInTheDocument();
        expect(screen.getByText('ÂøóÂ∑•Ôºö20 ‰∫∫')).toBeInTheDocument();
      });
    });

    it('should handle registration button click', async () => {
      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: mockEventDetails,
      });

      render(<EventDetailsPage />);

      await waitFor(() => {
        expect(screen.getByText('‰ª•Ê≥ïÂ∏´Ë∫´‰ªΩÂ†±Âêç')).toBeInTheDocument();
      });

      const registerButton = screen.getByText('‰ª•Ê≥ïÂ∏´Ë∫´‰ªΩÂ†±Âêç').closest('button');
      if (registerButton) {
        fireEvent.click(registerButton);
        expect(mockRouter.push).toHaveBeenCalledWith('/registration/event-1');
      }
    });

    it('should show error state when event not found', async () => {
      (apiClient.get as jest.Mock).mockRejectedValue(new Error('Event not found'));
      (require('../../services/api').handleApiError as jest.Mock).mockReturnValue('Êâæ‰∏çÂà∞Ê¥ªÂãï');

      render(<EventDetailsPage />);

      await waitFor(() => {
        expect(screen.getByText('ËºâÂÖ•Ê¥ªÂãïË©≥ÊÉÖÊôÇÁôºÁîüÈåØË™§')).toBeInTheDocument();
        expect(screen.getByText('Êâæ‰∏çÂà∞Ê¥ªÂãï')).toBeInTheDocument();
      });
    });

    it('should navigate back to events list', async () => {
      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: mockEventDetails,
      });

      render(<EventDetailsPage />);

      await waitFor(() => {
        expect(screen.getByText('‰æõ‰ΩõÈΩãÂÉßÊ≥ïÊúÉ')).toBeInTheDocument();
      });

      const backButton = screen.getByText('‚Üê ËøîÂõûÊ¥ªÂãïÂàóË°®');
      fireEvent.click(backButton);

      expect(mockRouter.push).toHaveBeenCalledWith('/events');
    });

    it('should show full event status correctly', async () => {
      const fullEvent = {
        ...mockEventDetails,
        currentParticipants: 100,
        maxParticipants: 100,
      };

      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: fullEvent,
      });

      render(<EventDetailsPage />);

      await waitFor(() => {
        expect(screen.getAllByText('Â∑≤È°çÊªø')).toHaveLength(3); // Header, alert, button
        expect(screen.getByText('Ê≠§Ê¥ªÂãïÂ†±Âêç‰∫∫Êï∏Â∑≤ÈÅî‰∏äÈôêÔºåÁÑ°Ê≥ïÂÜçÊé•ÂèóÂ†±Âêç„ÄÇ')).toBeInTheDocument();
      });
    });

    it('should show closed event status correctly', async () => {
      const closedEvent = {
        ...mockEventDetails,
        registrationDeadline: new Date('2020-01-01T00:00:00'), // Past date
      };

      (apiClient.get as jest.Mock).mockResolvedValue({
        success: true,
        data: closedEvent,
      });

      render(<EventDetailsPage />);

      await waitFor(() => {
        expect(screen.getAllByText('Â†±ÂêçÊà™Ê≠¢')).toHaveLength(4); // Header, alert, info section, button
        expect(screen.getByText('Ê≠§Ê¥ªÂãïÂ†±ÂêçÊôÇÈñìÂ∑≤Êà™Ê≠¢ÔºåÁÑ°Ê≥ïÂÜçÈÄ≤Ë°åÂ†±Âêç„ÄÇ')).toBeInTheDocument();
      });
    });
  });
});